using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators1;

[Generator]
public class ReusedObjectSourceGenerator : IIncrementalGenerator
{
	private const string AttributeName = "ReusedObjectAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// 过滤带有 [ReusedObject] 属性的类。只有被过滤的语法节点可以触发代码生成。
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				(s,   _) => s is ClassDeclarationSyntax,
				(ctx, _) => GetClassDeclarationForSourceGen(ctx))
			.Where(t => t.recycleAttributeFound)
			.Select((t, _) => t.Item1);

		// 生成代码
		context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
			((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
	}

	/// <summary>
	/// 检查节点是否带有 [ReusedObject] 属性，并将语法上下文映射到特定的节点类型 (ClassDeclarationSyntax)。
	/// </summary>
	/// <param name="context">基于 CreateSyntaxProvider 断言的语法上下文</param>
	/// <returns>特定的类型转换和属性是否被找到。</returns>
	private static (ClassDeclarationSyntax, bool recycleAttributeFound) GetClassDeclarationForSourceGen(
		GeneratorSyntaxContext context)
	{
		var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

		// Go through all attributes of the class.
		foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
		foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
		{
			if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
				continue; // if we can't get the symbol, ignore it

			string attributeName = attributeSymbol.ContainingType.ToDisplayString();
			
			// 如果是ReusedObject属性的话 就要为这个类 生成代码
			if (attributeName == $"{AttributeName}")
				return (classDeclarationSyntax, true);
		}

		return (classDeclarationSyntax, false);
	}

	/// <summary>
	/// 生成代码的操作。
	/// 它将在用户更改的特定节点（用 [ReusedObject] 属性注解的 ClassDeclarationSyntax）上执行。
	/// </summary>
	/// <param name="context">用于添加源文件的源生成上下文。</param>
	/// <param name="compilation">用于提供访问语义模型的编译。</param>
	/// <param name="classDeclarations">触发生成操作的带有 [ReusedObject] 属性的节点。</param>
	private void GenerateCode(SourceProductionContext                context, Compilation compilation,
	                          ImmutableArray<ClassDeclarationSyntax> classDeclarations)
	{
		// 遍历所有筛选出来的声明
		foreach (var classDeclarationSyntax in classDeclarations)
		{
			// 需要获取类的semanticModel以检索元数据。
			var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

			// 可以从symbols 获取到编译时信息
			if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
				continue;

			// var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

			// 'Identifier' 表示节点的标记。从语法节点获取类名。
			var className = classDeclarationSyntax.Identifier.Text;

			// 为每个字段 生成属性模板代码, 在getter 和 setter 检查 IsRecycled , 如果 为 true 则不能访问属性
			var fields = classSymbol.GetMembers()
				.OfType<IFieldSymbol>()
				.Select(p => $@"					  
	public {p.Type} {p.Name.ToUpperCamelCase()}
	{{
		get
		{{
			if (IsRecycled)
			{{
				throw new Exception($""{{this}} is recycled you can not access its property"");
			}}
			return {p.Name};
		}}

		set
		{{
			if (IsRecycled)
			{{
				throw new Exception($""{{this}} is recycled you can not access its property"");
			}}
			{p.Name} = value;
		}}
	}}");
			
			
			// 构建生成代码
			// 用 partial 关键字将生成的代码,和人写的代码分离,
			var code = $@"
// <auto-generated/>
			             
using System;
using System.Collections.Generic;

public partial class {className} : ReusedObject
{{
	 
	{string.Join("\n", fields)}

}}
";
			// Add the source code to the compilation.
			context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
		}
	}
}

/// <summary>
/// 工具类, 把小驼峰改为大驼峰
/// </summary>
public static class Helper
{
	public static string ToUpperCamelCase(this string s) =>
		string.Join("",
			s.Split('_').Where(cut => !string.IsNullOrEmpty(cut)).Select(c => char.ToUpper(c[0]) + c.Substring(1)));
}